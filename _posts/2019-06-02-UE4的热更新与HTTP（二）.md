---
layout:     post
title:      UE4的热更新与HTTP（二）
date:       2019-06-02
author:     BAJIAObujie
header-img: img/post-bg-cook.jpg
catalog: true



---

## 前言

上一篇文章讲了UE4源码里Http的部分内容，创建一条http请求，Http模块的结构。

这一篇内容来讲讲我在实现UE4的热更新中遇到的一些困难以及如何用UE4的Http来完成断点续传功能。



## UE4热更新的思路

比较版本文件

比较Md5文件

获取下载列表

下载文件



## 如何用UE4的HTTP下载多个小文件以及单个大文件   错误 标题错误



对于UE4所提供的HTTP接口来说，虽然封装得很好，但是与之相对的，实现的功能就不容易拓展，尤其是在不改变源码的情况下。先来看看HTTP留出了多少接口

1. 创建HTTP请求
2. 设置URL、Header、Verb
3. 每帧回调函数，完成回调函数

对于下载小文件来说，这真的是非常方便。只需要设置URL等一些基础属性，即可下载







比如网络突然中断的情况下，这个时候UE4的HTTP会被标记为完成，并且执行FinishedRequest，这个函数有两个分支，成功的话，就正常执行回调函数等等。失败的话会首先吧HttpResonse设置为NULL，然后再执行回调函数。也就是说如果失败，那么

在回调函数里，HttpResponse已经加载的内容就无法读取出来，因为已经被设置为NULL，同时bSucceeded是false。

` void OnRequestComplete(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded){}`



如果是Unity打包的话，这套打包机制简直为了它量身定制的，因为每个资源都是一个个独立的Bundle，那么只需要直接去下载就好了，下载失败，丢失数据就重新下载好了。但是UE4的话，热更新的文件列表里往往有一个pak的补丁包文件。这个补丁包集合了许多资源往往文件大小比较大。对手机平台来说，网络波动是很正常的事情，如果不小心网络中断，或者其他突发情况导致Http请求失败，那么这就意味着之前下载的数据全部消失。为了挽救它，我们需要在UE4的HTTP的基础上实现断点续传功能。









写到这里

=======================================================================









在拿到下载文件列表的时候，





断点续传意味着，如果断开了连接，那么下次下载的时候是能够恢复进度继续执行的



一个思路是

在HTTP下载数据的过程中就要把数据给保存在本地。那么来看看UE4提供的两个回调，每帧调用只能知道进度，并不知道实际下载的内容。而HTTP完成，有两种状态，成功的话能取到数据，失败的话拿不到数据。

这么一看这种传输方式最适合小文件。因为即使小文件失败了，那么直接重新下载就好了，如果失败了，那也就损失一点点流量。根本无所谓。但是如果是100、200M的文件，下载到最后突然一卡，导致HTTp失败，这个时候全盘重新下载是非常糟心的体验。



所以我的思路是用HTTP的Range头来坐断点续传，把一个大文件用很多个HTTP来下载，每个HTTP只下载文件的一部分。下载完成的时候，把这些零散的文件给拼接起来。重新组成一个完整的文件。这就是大概的思路。







既然要把文件分成多个HTTP分段下载，那么我们需要知道这个文件具体的大小，因为假设一个分段只有10M，只有知道文件的大小才能把文件给分段。



总之就是需要知道两个值，一个是URL，一个是文件大小。



。因为思路其实也不复杂 所以直接贴出代码











增强版： 1 下载多轮，如果有波动那么可以在下一轮继续下载

2  多任务同时下载











HttpRequest->OnProcessRequestComplete().BindUObject(this, &AMyActor::ReceiveHttp);

BindUObject是这个AMyActor是一个UObject。

BindRaw

BindLambda



BindRaw

![img](C:/Users/ZL0032/AppData/Local/YNote/data/weixinobU7VjnzO_xAtXfm4UdOFdCxjvQ4/456fe08182b043839f29d9368d0bb1e1/clipboard.png)

​	/**

​	 * Binds a raw C++ pointer delegate.

​	 *

​	 * Raw pointer doesn't use any sort of reference, so may be unsafe to call if the object was

​	 * deleted out from underneath your delegate. Be careful when calling Execute()!

​	 */



BindLambda

![img](C:/Users/ZL0032/AppData/Local/YNote/data/weixinobU7VjnzO_xAtXfm4UdOFdCxjvQ4/f326ed9e24ab471493d9b0d94f7ae690/clipboard.png)

​	/**

​	 * Static: Binds a C++ lambda delegate

​	 * technically this works for any functor types, but lambdas are the primary use case

​	 */



BindUobject

![img](C:/Users/ZL0032/AppData/Local/YNote/data/weixinobU7VjnzO_xAtXfm4UdOFdCxjvQ4/e9a9b849ba0142fdb64bf67a45ade9e7/clipboard.png)

​	/**

​	 * Binds a UObject-based member function delegate.

​	 *

​	 * UObject delegates keep a weak reference to your object.

​	 * You can use ExecuteIfBound() to call them.

​	 */





补充



void AMyActor::ProgressHttp(FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) {

​	int32 KB = BytesReceived / 1024;

​	int32 MB = KB / 1024;

​	int32 remainer = KB % 1024;

​	FString log = FString::Format(TEXT("{0}.{1}MB"), { MB, remainer });

​	GEngine->AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);

}



可以用这种方式打印到窗口查看下载进度





补充二





void AMyActor::WriteFile(FString& SavePath, TArray<uint8>& Content) {

​	if (!FPaths::FileExists(SavePath)) {

​		FFileHelper::SaveArrayToFile(Content, *SavePath);

​	}

​	else {

​		FArchive* FileWriter = IFileManager::Get().CreateFileWriter(*SavePath, EFileWrite::FILEWRITE_Append);

​		FileWriter->Serialize(Content.GetData(), Content.Num());

​		FileWriter->Close();

​	}

}

、

























补充三

给一个基础版的HTTP请求



头文件：

/*

class ANDROIDFIRST_API TestTask {

public:

​	TestTask(AMyActor* InTask, FString& InURL, int32 InIndex, int32 InFrom, int32 InTo) : Task(InTask), URL(InURL), Index(InIndex), From(InFrom), To(InTo) {

​	}



​	AMyActor* Task;

​	FString URL;

​	int32 Index;

​	int32 From;

​	int32 To;

​	FString SavePath;

​	bool bFinished;

​	void SendHttp();

​	void ReceiveHttp(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded);

​	void ProgressHttp(FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived);

};

*/



cpp



/*

\#pragma region TestTask



void TestTask::SendHttp() {

​	UE_LOG(LogTemp, Warning, TEXT("start text"));

​	TSharedRef<IHttpRequest> HttpRequest = FHttpModule::Get().CreateRequest();

​	HttpRequest->SetURL(URL);

​	HttpRequest->SetVerb(TEXT("GET"));

​	//HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("text/plain"));

​	HttpRequest->SetHeader(TEXT("Range"), TEXT("bytes=500-40000000"));

​	//HttpRequest->OnProcessRequestComplete().BindRaw(this, &TestTask::ReceiveHttp);

​	//HttpRequest->OnRequestProgress().BindRaw(this, &TestTask::ProgressHttp);

​	HttpRequest->OnRequestProgress().BindLambda([&](FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) {

​		UE_LOG(LogTemp, Warning, TEXT("URL:%s, From:%d, Receive:%d"), *URL, From, BytesReceived);

​	});

​	HttpRequest->OnProcessRequestComplete().BindLambda([&](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) {

​		UE_LOG(LogTemp, Warning, TEXT("Finished,%s,%d"), *URL, From);

​	});

​	//HttpRequest->OnRequestProgress().BindRaw(this, &TestTask::ProgressHttp);

​	HttpRequest->ProcessRequest();

}



void TestTask::ReceiveHttp(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) {

​	if (!bSucceeded) {

​		UE_LOG(LogTemp, Warning, TEXT("%d Not Succeeded"), Index);

​		return;

​	}

​	GEngine->AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, TEXT("Succeed"), true);

​	TArray<uint8> BinaryFileContent = HttpResponse->GetContent();

​	UE_LOG(LogTemp, Warning, TEXT("URL:%s, From:%d"), *URL, From);

​	//FFileHelper::SaveArrayToFile(BinaryFileContent, *SavePath);

​	//SaveLogFile();

}



void TestTask::ProgressHttp(FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) {

​	UE_LOG(LogTemp, Warning, TEXT("URL:%s, From:%d"), *URL, From);

​	int32 KB = BytesReceived / 1024;

​	int32 MB = KB / 1024;

​	int32 YU = KB % 1024;

​	FString log = FString::Format(TEXT("{0}.{1}MB"), { MB, YU });

​	//logFile.Add(log);

​	GEngine->AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);

}

\#pragma endregion



*/

