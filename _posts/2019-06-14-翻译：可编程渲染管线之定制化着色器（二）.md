## 前言

翻译：可编程渲染管线之定制化着色器（二）



## 定制化Shaders  HLSL与CoreLibrary

* 编写一个HLSL着色器
* 定义constant buffers
* 使用渲染管线Core Library
* 支持动态批处理和GPU Instancing

这是Unity的可编程渲染管线系列教程的第二篇文章。本文是关于使用HLSL创建一个shader，以及在单个DrawCall里通过batch批处理，高效渲染多个物体。

本篇教程使用的Unity版本是 2018.3.0f2。

![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/tutorial-image.jpg)

*256 spheres, a single draw call.*



### 1 定制Unity Shader

虽然我们已经可以在渲染管线中使用默认的unlit shader，但是高效利用定制渲染管线，也需要创建定制化shader。所以我们将会独立创建一个shader 取代 Unity的默认的unlit shader。（nontrivial 重要的）


#### 1.1 创建一个shader

shader资源可以通过Asset/Create/Shader 目录来创建。创建一个unlit shader好了，因为我们打算从零开始写代码，所以我们删除创建出来的shader的默认代码，并把这个资源命名为Unlit。

![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/custom-unlit-shader/unlit-shader.png)

*Unlit shader asset*

shader的基础教程在这个网址，如果你不熟悉编写shader那么就去读一读。让一个shader工作起来的最少需要定义一个shader块，这个shader块有一个属性块properties block 加上一个子着色器块subshader block（有一个pass block在 subshader里边）。在填上Shader的关键字My Pipeline/Unlit 之后，Unity会把这个shader变成一个默认的白色unlit shader 。接着就可以在材质里的shader的下拉框中找到。

```
Shader "My Pipeline/Unlit" {
	Properties {}
	SubShader {
		Pass {}
	}
}
```

修改Unlit Opaque材质，让它使用新的shader。这会让材质变成白色，即使shader都还没开始写。

![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/custom-unlit-shader/unlit-opaque-material.png)



#### 1.2 HLSL



```
		Pass {
			HLSLPROGRAM
			
			ENDHLSL
		}
```



```
			HLSLPROGRAM
			
			#pragma vertex UnlitPassVertex
			#pragma fragment UnlitPassFragment
			
			#include "Unlit.hlsl"
			
			ENDHLSL
```



```
#ifndef MYRP_UNLIT_INCLUDED
#define MYRP_UNLIT_INCLUDED

#endif // MYRP_UNLIT_INCLUDED
```



```
#ifndef MYRP_UNLIT_INCLUDED
#define MYRP_UNLIT_INCLUDED

struct VertexInput {
	float4 pos : POSITION;
};

struct VertexOutput {
	float4 clipPos : SV_POSITION;
};

#endif // MYRP_UNLIT_INCLUDED
```





```
struct VertexOutput {
	float4 clipPos : SV_POSITION;
};

VertexOutput UnlitPassVertex (VertexInput input) {
	VertexOutput output;
	output.clipPos = input.pos;
	return output;
}

#endif // MYRP_UNLIT_INCLUDED
```



```
VertexOutput UnlitPassVertex (VertexInput input) {
	VertexOutput output;
	output.clipPos = input.pos;
	return output;
}

float4 UnlitPassFragment (VertexOutput input) : SV_TARGET {
	return 1;
}

#endif // MYRP_UNLIT_INCLUDED
```



```
float4x4 unity_ObjectToWorld;

struct VertexInput {
	float4 pos : POSITION;
};

struct VertexOutput {
	float4 clipPos : SV_POSITION;
};

VertexOutput UnlitPassVertex (VertexInput input) {
	VertexOutput output;
	float4 worldPos = mul(unity_ObjectToWorld, input.pos);
	output.clipPos = worldPos;
	return output;
}
```









```
float4x4 unity_MatrixVP;
float4x4 unity_ObjectToWorld;

…

VertexOutput UnlitPassVertex (VertexInput input) {
	VertexOutput output;
	float4 worldPos = mul(unity_ObjectToWorld, input.pos);
	output.clipPos = mul(unity_MatrixVP, worldPos);
	return output;
}
```



```
float4 worldPos = mul(unity_ObjectToWorld, float4(input.pos.xyz, 1.0));v
```





```
cbuffer UnityPerFrame {
	float4x4 unity_MatrixVP;
};

cbuffer UnityPerDraw {
	float4x4 unity_ObjectToWorld;
}
```



#### 1.5 Core Library

```
CBUFFER_START(UnityPerFrame)
	float4x4 unity_MatrixVP;
CBUFFER_END

CBUFFER_START(UnityPerDraw)
	float4x4 unity_ObjectToWorld;
CBUFFER_END
```

![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/custom-unlit-shader/core-package.png)

```
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

CBUFFER_START(UnityPerFrame)
float4x4 unity_MatrixVP;
CBUFFER_END
```





#### 1.6 

```
			#pragma target 3.5
			
			#pragma vertex UnlitPassVertex
			#pragma fragment UnlitPassFragment
```





#### 1.7



![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/custom-unlit-shader/folder-structure.png)



```
			#include "../ShaderLibrary/Unlit.hlsl"
```





## 2



![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/dynamic-batching/spheres.png)







```
		var drawSettings = new DrawRendererSettings(
			camera, new ShaderPassName("SRPDefaultUnlit")
		);
		drawSettings.flags = DrawRendererFlags.EnableDynamicBatching;
		drawSettings.sorting.flags = SortFlags.CommonOpaque;
```





![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/dynamic-batching/no-batching.png)





![scene](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/dynamic-batching/cubes.png)



![frame debugger](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/dynamic-batching/batched.png)



#### 2.2

```
	Properties {
		_Color ("Color", Color) = (1, 1, 1, 1)
	}
```





```
	public override void Render (
		ScriptableRenderContext renderContext, Camera[] cameras
	) {
		base.Render(renderContext, cameras);

		//renderContext.DrawSkybox(cameras[0]);

		//renderContext.Submit();

		foreach (var camera in cameras) {
			Render(renderContext, camera);
		}
	}
```



```
	void Render (ScriptableRenderContext context, Camera camera) {
		context.SetupCameraProperties(camera);

		context.DrawSkybox(camera);

		context.Submit();
	}
```



#### 2.3 Command Buffers



```
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Experimental.Rendering;

public class MyPipeline : RenderPipeline {

	…

	void Render (ScriptableRenderContext context, Camera camera) {
		context.SetupCameraProperties(camera);

		var buffer = new CommandBuffer();

		context.DrawSkybox(camera);

		context.Submit();
	}
}
```



```
	var buffer = new CommandBuffer();
		context.ExecuteCommandBuffer(buffer);
```



```
	var buffer = new CommandBuffer();
		context.ExecuteCommandBuffer(buffer);
		buffer.Release();
```



```
		var buffer = new CommandBuffer();
		buffer.ClearRenderTarget(true, false, Color.clear);
		context.ExecuteCommandBuffer(buffer);
		buffer.Release();
```





![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/frame-debugger-clear-command.png)





```
		CameraClearFlags clearFlags = camera.clearFlags;
		buffer.ClearRenderTarget(
			(clearFlags & CameraClearFlags.Depth) != 0,
			(clearFlags & CameraClearFlags.Color) != 0,
			camera.backgroundColor
		);
```



```
		var buffer = new CommandBuffer {
			name = camera.name
		};
```



![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/frame-debugger-camera-name.png)

#### 2.4 Culling



```
	void Render (ScriptableRenderContext context, Camera camera) {
		ScriptableCullingParameters cullingParameters;
		CullResults.GetCullingParameters(camera, out cullingParameters);

		…
	}
```



```
		if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {
			return;
		}
```



```
if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {
			return;
		}

		CullResults cull = CullResults.Cull(ref cullingParameters, context);
```



#### 2.5 Drawing



```
		buffer.Release();

		var drawSettings = new DrawRendererSettings();

		var filterSettings = new FilterRenderersSettings();

		context.DrawRenderers(
			cull.visibleRenderers, ref drawSettings, filterSettings
		);

		context.DrawSkybox(camera);
```





```
		var filterSettings = new FilterRenderersSettings(true);
```

```
		var drawSettings = new DrawRendererSettings(
			camera, new ShaderPassName("SRPDefaultUnlit")
		);
```







![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/opaque-only.jpg)



![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/frame-debugger-draw.png)













