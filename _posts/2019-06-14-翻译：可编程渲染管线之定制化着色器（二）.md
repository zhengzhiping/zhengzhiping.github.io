## 前言

翻译：可编程渲染管线之定制化着色器（二）



## 定制化Shaders  HLSL与CoreLibrary

* 编写一个HLSL着色器
* 定义constant buffers
* 使用渲染管线Core Library
* 支持动态批处理和GPU Instancing

这是Unity的可编程渲染管线系列教程的第二篇文章。本文是关于使用HLSL创建一个shader，以及在单个DrawCall里通过batch批处理，高效渲染多个物体。

本篇教程使用的Unity版本是 2018.3.0f2。

![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/tutorial-image.jpg)

*256 spheres, a single draw call.*



### 1 定制Unity Shader

虽然我们已经可以在渲染管线中使用默认的unlit shader，但是高效利用定制渲染管线，也需要创建定制化shader。所以我们将会独立创建一个shader 取代 Unity的默认的unlit shader。（nontrivial 重要的）


#### 1.1 创建一个shader

shader资源可以通过Asset/Create/Shader 目录来创建。创建一个unlit shader好了，因为我们打算从零开始写代码，所以我们删除创建出来的shader的默认代码，并把这个资源命名为Unlit。

![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/custom-unlit-shader/unlit-shader.png)

*Unlit shader asset*

shader的基础教程在这个网址，如果你不熟悉编写shader那么就去读一读。让一个shader工作起来的最少需要定义一个shader块，这个shader块有一个属性块properties block 加上一个子着色器块subshader block（有一个pass block在 subshader里边）。在填上Shader的关键字My Pipeline/Unlit 之后，Unity会把这个shader变成一个默认的白色unlit shader 。接着就可以在材质里的shader的下拉框中找到。

```
Shader "My Pipeline/Unlit" {
	Properties {}
	SubShader {
		Pass {}
	}
}
```

修改Unlit Opaque材质，让它使用新的shader。这会让材质变成白色，即使shader都还没开始写。

![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/custom-unlit-shader/unlit-opaque-material.png)



#### 1.2 HLSL

为了编写shader，我们必须在pass块中放入一段程序。Unity支持GLSL和HLSL两种代码语言。GLSL用在默认的shader还有

？？？

HLSL的新渲染管线则使用了HLSL。所以我们的渲染管线也会使用HLSL。这意味着我们必须把我们的代码放在 HLSLPROGRAM 和 ENDHLSL 中间。

```
		Pass {
			HLSLPROGRAM
			
			ENDHLSL
		}
```



> GLSL 和 HLSL有什么不同呢
>
> 实际上，Unity为两种语言使用相同的语义（定义UnityShader专用的语言），并且根据目标平台的不同，会处理UnityShader代码转化成适合目标平台工作的shader代码的工作。
>
> 最大的不同点就是GLSL会隐式的include一些代码，而HLSL不会隐式的帮我们处理这些事情，这就要求我们使用HLSL的时候，需要做什么工作，就需要显式的include什么文件。这一点不错，因为旧版本的GLSL的include文件被一些老旧过时的代码给拖累的。我们将会使用更新的HLSL include文件。



Unity的shader最少需要一个顶点函数和一个片元函数。这两个函数都用 pragma 来定义。我们定义顶点函数为 UnlitPassVertex， 片元函数为 UnlitPassFragment 。但我们不会把这两个函数的代码直接放在shader文件里。我们把HLSL文件单独放在一个“include文件”中（意思是代码放在另外一个文件里，然后shader include这个代码文件，就称代码文件为include文件）。这个include文件起名为 Unlit，以 hlsl 为后缀。把它放在和 Unlit 一样的文件夹下。在使用 pragma定义顶点函数、片元函数后，就可以include这个文件了。

```
			HLSLPROGRAM
			
			#pragma vertex UnlitPassVertex
			#pragma fragment UnlitPassFragment
			
			#include "Unlit.hlsl"
			
			ENDHLSL
```





不幸的是，Unity并没有一个方便的选项来让我们创建 hlsl 文件资源。我们必须自己来创建，例如通过复制 Unlit.shader 文件，然后改拓展名，再把shader代码移除。





在这个include文件里（也就是编写顶点函数、片元函数的 hlsl 文件），会设置一个 guard 标志来避免这个文件在被include多次的情况下产生重复代码。最好在每一个include文件都这么做。

```
#ifndef MYRP_UNLIT_INCLUDED
#define MYRP_UNLIT_INCLUDED

#endif // MYRP_UNLIT_INCLUDED
```



（弄完文件之后就是具体的编写hlsl代码了）

在顶点函数中，我们最少需要知道顶点位置，顶点位置是必须输出到裁剪空间位置的。所以我们为顶点函数定义两个结构体，input结构体和output结构体。这两个结构体都带有一个 float4的变量，表示位置。

```
#ifndef MYRP_UNLIT_INCLUDED
#define MYRP_UNLIT_INCLUDED

struct VertexInput {
	float4 pos : POSITION;
};

struct VertexOutput {
	float4 clipPos : SV_POSITION;
};

#endif // MYRP_UNLIT_INCLUDED
```



接着我们来实现 UnlitPassVertex 这个顶点函数。现在我们直接把局部空间的顶点位置输出为裁剪空间的位置。这是不正确的空间转换，但这是最快的方式来获取一个编译好的shader。我们将在稍后纠正。

```
struct VertexOutput {
	float4 clipPos : SV_POSITION;
};

VertexOutput UnlitPassVertex (VertexInput input) {
	VertexOutput output;
	output.clipPos = input.pos;
	return output;
}

#endif // MYRP_UNLIT_INCLUDED
```



（在片元函数里）目前我们保持输出颜色为默认的白色即可。所以片元处理函数只需要返回一个 1，float4 类型的值。顶点函数的输出后作为片元函数的输入，所以要把它作为参数，即使我们现在用不到。

```
VertexOutput UnlitPassVertex (VertexInput input) {
	VertexOutput output;
	output.clipPos = input.pos;
	return output;
}

float4 UnlitPassFragment (VertexOutput input) : SV_TARGET {
	return 1;
}

#endif // MYRP_UNLIT_INCLUDED
```



> 我们是否使用half 或者 float
>
> 大部分移动设备GPU都支持这两种precision types精度类型， half会更加高效一些。所以如果你正在为移动设备做优化工作，那么应该尽可能的使用half。 如果结果是可以接收的情况下,那么一般规则是 只对positions位置和texture coordinate纹理坐标使用float，其他的则全部用half。（The rule is to use **float** for positions and texture coordinate only and **half** for everything else, provided that the results are acceptable.）
>
> （Provided that 如果是、假如）
>
> 如果目标不是移动平台，精度并不是一个大问题。因为GPU总是会使用float，即使我们写half也是一样。之后的教程基本都是写float的。
>
> 其实还有一个fixed精度，但它只被一些比较老的设备支持，基本上现在的app不会考虑安装在这些设备上，（所以基本可以忽略了），fixed这个精度通常是等同于half的。



#### 1.3 Transformation Matrices 矩阵变换

现在我们有了一个编译成功的shader了，但它尚未产生正确的结果。下一步就是把顶点位置转化到正确的空间位置。如果我们有一个MVP矩阵，我们可以直接从局部空间转化到裁剪空间，但Unity并没有为我们提供这么一个矩阵，Unity为我们提供了局部空间到世界空间的矩阵。Unity希望我们的shader有一个 float4*4 的unity_ObjectToWorld 变量来存储矩阵。因为我们是用HLSL工作的，所以我们必须自己来定义这个变量。然后才可以在顶点函数中使用它转化位置到世界空间的位置，并使用这个世界空间的位置作为输出结果。



```
float4x4 unity_ObjectToWorld;

struct VertexInput {
	float4 pos : POSITION;
};

struct VertexOutput {
	float4 clipPos : SV_POSITION;
};

VertexOutput UnlitPassVertex (VertexInput input) {
	VertexOutput output;
	float4 worldPos = mul(unity_ObjectToWorld, input.pos);
	output.clipPos = worldPos;
	return output;
}
```



接着我们需要转化世界空间到裁剪空间。这个工作可以被VP矩阵完成。Unity也为我们提供了float4*4 unity_MatrixVP 变量来作为VP矩阵，这样就完成了空间转化

```
float4x4 unity_MatrixVP;
float4x4 unity_ObjectToWorld;

…

VertexOutput UnlitPassVertex (VertexInput input) {
	VertexOutput output;
	float4 worldPos = mul(unity_ObjectToWorld, input.pos);
	output.clipPos = mul(unity_MatrixVP, worldPos);
	return output;
}
```



> 我修改了代码，但它还没有生效？
>
> 

我们的shader现在已经正确执行了。所有使用这个 unlit material 的物体又是可见的了，显示为白色。但是我们的空间转化可以更加高效，因为空间转化是使用一个4D的位置向量来做矩阵乘法。向量的第四个值总是为1，通过显式声明，我们可以使编译器优化计算。

```
float4 worldPos = mul(unity_ObjectToWorld, float4(input.pos.xyz, 1.0));v
```



#### 1.4 Constant Buffer 常量缓存区

-----------------===============

```
cbuffer UnityPerFrame {
	float4x4 unity_MatrixVP;
};

cbuffer UnityPerDraw {
	float4x4 unity_ObjectToWorld;
}
```



#### 1.5 Core Library

```
CBUFFER_START(UnityPerFrame)
	float4x4 unity_MatrixVP;
CBUFFER_END

CBUFFER_START(UnityPerDraw)
	float4x4 unity_ObjectToWorld;
CBUFFER_END
```

![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/custom-unlit-shader/core-package.png)

```
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

CBUFFER_START(UnityPerFrame)
float4x4 unity_MatrixVP;
CBUFFER_END
```





#### 1.6 

```
			#pragma target 3.5
			
			#pragma vertex UnlitPassVertex
			#pragma fragment UnlitPassFragment
```





#### 1.7



![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/custom-unlit-shader/folder-structure.png)



```
			#include "../ShaderLibrary/Unlit.hlsl"
```





## 2



![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/dynamic-batching/spheres.png)







```
		var drawSettings = new DrawRendererSettings(
			camera, new ShaderPassName("SRPDefaultUnlit")
		);
		drawSettings.flags = DrawRendererFlags.EnableDynamicBatching;
		drawSettings.sorting.flags = SortFlags.CommonOpaque;
```





![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/dynamic-batching/no-batching.png)





![scene](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/dynamic-batching/cubes.png)



![frame debugger](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/dynamic-batching/batched.png)



#### 2.2

```
	Properties {
		_Color ("Color", Color) = (1, 1, 1, 1)
	}
```





```
	public override void Render (
		ScriptableRenderContext renderContext, Camera[] cameras
	) {
		base.Render(renderContext, cameras);

		//renderContext.DrawSkybox(cameras[0]);

		//renderContext.Submit();

		foreach (var camera in cameras) {
			Render(renderContext, camera);
		}
	}
```



```
	void Render (ScriptableRenderContext context, Camera camera) {
		context.SetupCameraProperties(camera);

		context.DrawSkybox(camera);

		context.Submit();
	}
```



#### 2.3 Command Buffers



```
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Experimental.Rendering;

public class MyPipeline : RenderPipeline {

	…

	void Render (ScriptableRenderContext context, Camera camera) {
		context.SetupCameraProperties(camera);

		var buffer = new CommandBuffer();

		context.DrawSkybox(camera);

		context.Submit();
	}
}
```



```
	var buffer = new CommandBuffer();
		context.ExecuteCommandBuffer(buffer);
```



```
	var buffer = new CommandBuffer();
		context.ExecuteCommandBuffer(buffer);
		buffer.Release();
```



```
		var buffer = new CommandBuffer();
		buffer.ClearRenderTarget(true, false, Color.clear);
		context.ExecuteCommandBuffer(buffer);
		buffer.Release();
```





![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/frame-debugger-clear-command.png)





```
		CameraClearFlags clearFlags = camera.clearFlags;
		buffer.ClearRenderTarget(
			(clearFlags & CameraClearFlags.Depth) != 0,
			(clearFlags & CameraClearFlags.Color) != 0,
			camera.backgroundColor
		);
```



```
		var buffer = new CommandBuffer {
			name = camera.name
		};
```



![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/frame-debugger-camera-name.png)

#### 2.4 Culling



```
	void Render (ScriptableRenderContext context, Camera camera) {
		ScriptableCullingParameters cullingParameters;
		CullResults.GetCullingParameters(camera, out cullingParameters);

		…
	}
```



```
		if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {
			return;
		}
```



```
if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {
			return;
		}

		CullResults cull = CullResults.Cull(ref cullingParameters, context);
```



#### 2.5 Drawing



```
		buffer.Release();

		var drawSettings = new DrawRendererSettings();

		var filterSettings = new FilterRenderersSettings();

		context.DrawRenderers(
			cull.visibleRenderers, ref drawSettings, filterSettings
		);

		context.DrawSkybox(camera);
```





```
		var filterSettings = new FilterRenderersSettings(true);
```

```
		var drawSettings = new DrawRendererSettings(
			camera, new ShaderPassName("SRPDefaultUnlit")
		);
```







![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/opaque-only.jpg)



![img](https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/frame-debugger-draw.png)













